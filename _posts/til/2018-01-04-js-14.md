---
layout: post
title: 18년 1월 4일 수업 내용 정리
description: 패스트캠퍼스 프론트엔드 스쿨 수업 내용 정리 (js) # Add post description (optional)
img: post-til.jpg # Add image post (optional)
tags: [패스트캠퍼스, til, js, javascript]
author: # Add name author (optional)
category: til
---
# Today I Learned

> 패스트캠퍼스 김승하 강사님의 수업 내용 중 새로 알게 됐거나 조금이라도 헷갈릴 수 있는 내용들을 모두 정리했습니다.

### 4. DOM 

#### 4.1 Drag & Drop

1. Drag & Drop을 구현하기 위해 움직이려는 요소에 mousemove 이벤트를 에 등록하면, 마우스를 빠르게 움직일 때 요소가 속도를 잘 따라오지 못하는 등의 이슈가 발생한다. 따라서 mousemove 이벤트는 document 객체에 등록하도록 한다.

2. mouseup 이벤트는 브라우저 화면 내에서 마우스를 놨을 때만 발생한다. 따라서 드래그 중이던 요소를 브라우저 외부에서 놓은 후 다시 브라우저 내부로 가져오면  마우스가 눌려있지 않았음에도 해당 요소가 여전히 마우스에 따라 움직인다. 이런 이슈를 해결하기 위해서는 mouseup 이벤트 역시 document 객체에 등록해야 한다.

   ```html
   <!DOCTYPE html>
   <html lang="en">

   <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta http-equiv="X-UA-Compatible" content="ie=edge">
     <title>Document</title>
     <style>
       .outer {
         position: relative;
         margin: 50px;
         height: 300px;
         background-color: aquamarine;
       }

       .box {
         position: absolute;
         width: 50px;
         height: 50px;
         top: 10px;
         left: 10px;
         background-color: blue;
         cursor: pointer;
       }

     </style>
   </head>

   <body>
     <div class="outer">
       <div class="box"></div>
     </div>
     <script>
       let dragging = false;

       const box = document.querySelector('.box');
       let originalX;
       let originalY;
       let originalLeft;
       let originalTop;

       box.addEventListener('mousedown', e => {
         console.log('mousedown');
         dragging = true;
         originalX = e.clientX;
         originalY = e.clientY;
         originalLeft = box.offsetLeft;
         originalTop = box.offsetTop;
         // 클릭이 일어난 순간에 상대적 위치 저장
         // el.offsetLeft, el.offsetTop
         // el.getBoundingClientRect()
       })
       document.addEventListener('mouseup', e => {
         console.log('mouseup');
         dragging = false;
       })
       document.addEventListener('mousemove', e => {
         console.log('mousemove');
         if (dragging) {
           // 상대적 위치를 유지하며 박스 위치 변경
           const diffX = e.clientX - originalX;
           const diffY = e.clientY - originalY;
           const largeBox = document.querySelector('.outer').getBoundingClientRect();
           const smallBox = box.getBoundingClientRect();
           const resultX = Math.min(
             Math.max(0, originalLeft + diffX),
             largeBox.width - smallBox.width
           );
           const resultY = Math.min(
             Math.max(0, originalTop + diffY),
             largeBox.height - smallBox.height
           );
           box.style.left = `${resultX}px`;
           box.style.top = `${resultY}px`;
         }
       })

     </script>

   </body>

   </html>
   ```


<br />

#### 4.2 form 이벤트: change vs input 

1. input 이벤트는 값이 입력될 때마다 발생하고, change 이벤트는 입력 값이 바뀐 상태에서 포커스가 이동할 때 발생한다.

2. 텍스트를 입력받는 태그(text, tel, password 등)에는 input 이벤트를 붙여야 하고, 텍스트를 입력하지 않는 요소(checkbox 등)에는 change 이벤트를 붙이도록 한다.

3. [devdocs - input 이벤트](http://devdocs.io/dom_events/input)

4. `contenteditable` 속성을 이용하여 사용자로부터 입력을 받을 수도 있다. `contenteditable` 속성을 가진 경우 또한 `input` 이벤트를 수신할 수 있다.

   ```html
   <div contenteditable>Hello World</div>
   ```

<br />

> ##### 크롬 개발자 도구의 네트워크 탭
>
> 1. 크롬 개발자 도구의 네트워크 탭에서 현재 페이지에서 요청을 보내거나 응답 데이터를 받을 때 일어나고 있는 모든 네트워크 전송을 확인할 수 있다.

<br />

#### 4.3 Parallax Scroll

1. 페이지에 이벤트를 걸어 UI 효과를 만드는 방법을 parallax scroll이라 한다. 직접 구현하는 것은 어려움 작업이고, 관련 라이브러리를 사용하면 된다.
2. Bootstrap의 Scrollspy 등이 있다.
3. scroll 이벤트에 대한 이벤트 객체는 일반적인 우리의 기대와 다르게, scroll 관련 이벤트 정보를 갖고 있지 않다. 얼만큼 스크롤되었는지 확인하고 싶다면 window 객체의 `window.scrollY` 속성을 이용한다.

<br />

> ##### 텍스트 자동 채우기
>
> 1. html 문서에서 lorem2000 입력 후 탭 키를 누르면 그 내부에 2000단어가 자동으로 채워진다.

<br />

#### 4.4 progress 이벤트

1. viedo 요소의 progress 이벤트에 event listener를 등록하면 짧은 시간 간격마다 progress 이벤트가 발생하면서 얼만큼 재생되었는지에 대한 정보를 제공받을 수 있다.

<br />

### 5. 파이어베이스 

#### 5.1 시작하기

1. 파이어베이스 Console에서 프로젝트를 생성한다.
2. Project Overview 탭에서 '웹 앱에 Firebase 추가'를 클릭한다.
3. 위 과정을 거치면 코드 스니펫을 확인할 수 있는데, 해당 코드 스니펫은 프로젝트에 대한 식별 번호이다. 해당 코드를 복사 후 사용하고자 하는 프로젝트에 붙여넣는다.
4. [Web에서 Firebase 시작하기](https://firebase.google.com/docs/web/setup)

<br />

#### 5.2 인증

1. firebase를 우리가 사용할 자원을 저장하고 있는 '자원 서버', github을 인증을 가능케할 계정을 제공하는 '인증 서버'라고 할 때, 인증 서버와 자원 서버가 다름에도 통신을 가능케 해주는 규약을 OAuth라고 한다.

2. github 계정을 통해 firebase 앱에 로그인할 때, github 페이지가 잠시 보이고, 로그인이 이뤄진 뒤에 인증 정보를 파이어베이스에 전송해주는 과정을 거치는데, 이 과정을 redirect 절차라고 한다.

3. Github 계정을 통한 인증 기능 구현 절차는 다음과 같다.

   1. 자바스크립트 프로젝트에 Firebase를 추가한다.
   2. GitHub에서 개발자 애플리케이션으로 [앱을 등록](https://github.com/settings/applications/new)한다. 이때 Authorization callback URL 입력란이 있는데, Authorization callback은 인증 결과를 firebase에 전송하는 것을 의미한다. 해당 입력란에 입력할 url 정보는 [프로젝트 Console] - [DEVELOP] - [Authenticaiton] - [로그인 방법 설정] - [Github]으로 이동하여 확인할 수 있다.
   3. 앱의 OAuth 2.0 **클라이언트 ID**와 **클라이언트 비밀번호**를 가져온다. 파이어베이스 Console에서 [Authenticaiton] - [로그인 방법] - [Github]으로 이동하여 '사용 설정'하고 클라이언트 ID 및 비밀번호 입력란을 확인할 수 있는데, 이 곳에 입력할 정보는 Github 계정에서 [Settings] - [Developer Settings]로 이동하여 확인할 수 있다.
   4. 위 과정을 모두 거쳤으면 Github 계정을 통한 인증 기능을 구현할 준비가 된 것이다. 각 제공 업체마다 설정 방법은 조금씩 다르지만, 이와 비슷한 방법으로 설정할 수 있다.

4. Github 인증 기능 통신을 위한 Github Auth Provider 인스턴스를 생성하기 위해 프로젝트에 다음 코드를 추가한다.

   ```javascript
   var provider = new firebase.auth.GithubAuthProvider();
   ```

5. 나머지 절차는 [Github으로 인증하기](https://firebase.google.com/docs/auth/web/github-auth)에서 확인할 수 있다.

6. 토큰은 자신이 누구인지 밝혀주는 정보이다. REST API에서 아이디 및 비밀번호 대신 토큰을 사용하여 인증한다.

<br />

<br />

## 5 Day

### 1. 파이어베이스 

#### 1.1 실시간 데이터베이스

1. Backend에서 사용하는 데이터베이스는 그들만의 데이터 저장소가 따로 존재하는 반면, 실시간 데이터베이스는 그냥 하나의 JSON 통이라 할 수 있다(JSON 트리).
2. 실시간 데이터베이스라는 그 이름대로, 실시간으로 데이터의 업데이트를 감지한다.
3. 규칙 설정을 통해 데이터 보안을 설정할 수 있다. 이를 인증 기능과 연계하여 인증한 사용자만 접근할 수 있는 데이터를 관리할 수 있다.
4. **배열은 지원하지 않는다**는 단점이 있다. 오로지 **객체**만 지원한다.
5. 여러 필터, 혹은 여러 정렬 기준이 필요한 복잡한 쿼리는 지원하지 않는다. 이러한 기능이 필요한 경우라면, 현 시점에서 베타 단계에 있는 [Firestore](https://firebase.google.com/docs/firestore/?hl=ko)의 사용을 고려해볼 수 있다.
6. 규칙 설정에서 `.read`는 실시간 데이터베이스를 읽을 수 있는 조건을 나타내고, `.write`는 쓸 수 있는 조건을 나타낸다.
7. `auth != null`에서 auth는 사전 정의 변수로, 인증이 된 상태일 때 해당 변수에 사용자 객체가 담겨있고, 인증이 되지 않은 상태일 때 `null`이 담겨있다. 기본 규칙 설정을 그대로 사용한다면, 인증이 된 상태이기만 하면 모든 데이터를 읽고 쓸 수 있다.
8. 채팅 방에 대한 데이터베이스가 있다고 가정해보자. 채팅 방에 대한 정보, 메세지에 대한 정보를 따로 저장한 다음, 속성 필드를 이용해 관계를 명시해주는 것을 정규화(normalize)라고 한다.
9. 데이터를 일부만 변경하고 싶을 때 `update()`를 사용하고, 통째로 변경하고 싶을 때 `set()`을 사용한다.