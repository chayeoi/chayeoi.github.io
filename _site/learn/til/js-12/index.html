<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="utf-8">
	<title>17년 12월 21일 수업 내용 정리 - Oh My Charlie</title>
	<meta name="description" content="패스트캠퍼스 프론트엔드 스쿨 수업 내용 정리 (js)">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta property="og:image" content="">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-touch-icon-114x114.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#311e3e">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#311e3e">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#311e3e">
	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">
	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
  <div class="flex-container">
  <header class="main-header">
  <div class="header-wrapper">
    <div class="header-flex">
      <h1 class="logo"><a href="/" title="홈 화면">Oh My Charlie</a></h1>
      <div class="menu-icon-container">
        <span class="menu-icon"><i class="fa fa-bars" aria-hidden="true"></i></span>
      </div>
      <nav class="main-nav">
        <h2 class="nav-heading-invisible">네비게이션</h2>
        <span class="menu-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
        <ul>
          
            <li><a href="/" title="Home">Home</a></li>
          
            <li><a href="/about" title="About me">About</a></li>
          
            <li><a href="/html5" title="HTML5">HTML5</a></li>
          
            <li><a href="/css3" title="CSS3">CSS3</a></li>
          
            <li><a href="/js" title="Javascript">Javascript</a></li>
          
            <li><a href="/til" title="Today I Learned">Today I Learned</a></li>
           
        </ul>
      </nav>
      <div class="search-icon-container">
        <span class="search-icon"><a><i class="fa fa-search" aria-hidden="true"></i></a></span>
      </div>
    </div>
  </div>
</header> <!-- End Header -->

  <article class="article-page">
    <div class="page-image">
      <div class="cover-image" style="background: url(/assets/img/post-til.jpg) center no-repeat; background-size: cover;"></div>
    </div>
    <div class="wrapper">
      <div class="page-content">
        <div class="header-page">
          <h1 class="page-title">17년 12월 21일 수업 내용 정리</h1>
          <div class="page-date"><time datetime="2018-01-02 00:00:00 +0900">2018, Jan 02</time></div>
        </div>
        <h1 id="today-i-learned">Today I Learned</h1>

<blockquote>
  <p>패스트캠퍼스 김승하 강사님의 수업 내용 중 정확히 몰랐거나 헷갈렸던  내용을 모두 발췌함.</p>
</blockquote>

<h2 id="2-day">2 Day</h2>

<h3 id="1-iterable">1. Iterable</h3>

<h4 id="11-iterable이란">1.1 Iterable이란?</h4>

<ol>
  <li>
    <p>반복 가능한 객체(iterable object)는 <code class="highlighter-rouge">for...of</code> 구문과 함께 ES2015에서 도입되었다. 반복 가능한 객체를 다른 객체와 구분짓는 특징은, 객체의 <code class="highlighter-rouge">Symbol.iterator</code> 속성에 <strong>특별한 형태의 함수</strong>가 들어있다는 것이다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">'hello'</span><span class="p">;</span>
<span class="nx">str</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span> <span class="c1">// [Function]</span>

<span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">arr</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span> <span class="c1">// [Fu`nction: values]</span>

<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="nx">map</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span> <span class="c1">// [Function: entries]</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">obj</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span> <span class="c1">// undefined</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>객체의 <code class="highlighter-rouge">Symbol.iterator</code> 속성에 특정 형태의 함수가 들어있다면, 이를 반복 가능한 객체(iterable object) 혹은 줄여서 <strong>iterable</strong>이라 부르고, <strong>해당 객체는 iterable protocol을 만족한다</strong>고 말한다. 이런 객체들에 대해서는 ES2015에서 추가된 다양한 기능들을 사용할 수 있다.</p>
  </li>
  <li>
    <p>내장된 생성자 중 iterable 객체를 만들어내는 생성자에는 아래와 같은 것들이 있다.</p>

    <ol>
      <li><code class="highlighter-rouge">String</code></li>
      <li><code class="highlighter-rouge">Array</code></li>
      <li><code class="highlighter-rouge">TypedArray</code></li>
      <li><code class="highlighter-rouge">Map</code></li>
      <li><code class="highlighter-rouge">Set</code></li>
    </ol>
  </li>
  <li>
    <p><code class="highlighter-rouge">Symbol.iterator</code>는 자바스크립트 엔진이 미리 만들어놓은 내장 Symbol 값이다.</p>
  </li>
</ol>

<p><br /></p>

<h4 id="12-iterable의-사용">1.2 Iterable의 사용</h4>

<ol>
  <li>
    <p>어떤 객체가 Iterable이라면, 그 객체에 대해서 아래의 기능들을 사용할 수 있다.</p>

    <ul>
      <li><code class="highlighter-rouge">for...of</code> 루프</li>
      <li>spread 연산자 (<code class="highlighter-rouge">...</code>)</li>
      <li>분해대입(destructuring assignment)</li>
      <li>기타 iterable을 인자로 받는 함수</li>
    </ul>
  </li>
  <li>
    <p>즉, <strong>문자열에 대해서도 위 기능들을 사용할 수 있다.</strong></p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 'for...of'</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">c</span> <span class="k">of</span> <span class="s1">'hello'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// spread 연산자</span>
<span class="kd">const</span> <span class="nx">characters</span> <span class="o">=</span> <span class="p">[...</span><span class="s1">'hello'</span><span class="p">];</span>

<span class="c1">// 분해대입</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'hello'</span><span class="p">;</span>

<span class="c1">// `Array.from`은 iterable 혹은 array-like 객체를 인자로 받는다.</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h4 id="13-generator-함수">1.3 Generator 함수</h4>

<ol>
  <li>
    <p>그러면 우리가 직접 iterable인 객체를 만들 수는 없을까? 결론부터 말하면, iterable protocol을 구현하기만 하면 <strong>어떤 객체든 iterable이 될 수 있다.</strong></p>
  </li>
  <li>
    <p>Iterable을 구현하는 가장 쉬운 방법은 ES2015에 도입된 <strong>generator 함수</strong>를 사용하는 것이다.</p>
  </li>
  <li>
    <p>Generator 함수는 <strong>iterable 객체를 반환하는 특별한 형태의 함수</strong>이다. 아래와 같은 문법을 통해 generator 함수를 정의할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// generator 함수 선언하기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">gen1</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 표현식으로 사용하기</span>
<span class="kd">const</span> <span class="nx">gen2</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 메소드 문법으로 사용하기</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="o">*</span> <span class="nx">gen3</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Generator 함수를 호출하면 객체가 생성되는데, 이 객체는 iterable protocol을 만족한다. 즉, <code class="highlighter-rouge">Symbol.iterator</code>속성을 갖고 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">gen1</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// `gen1`를 호출하면 iterable이 반환된다.</span>
<span class="kd">const</span> <span class="nx">iterable</span> <span class="o">=</span> <span class="nx">gen1</span><span class="p">();</span>

<span class="nx">iterable</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">];</span> <span class="c1">// [Function]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Generator 함수 안에서는 <code class="highlighter-rouge">yield</code>라는 특별한 키워드를 사용할 수 있다. Generator 함수 안에서 <code class="highlighter-rouge">yield</code> 키워드는 <code class="highlighter-rouge">return</code>과 유사한 역할을 하며, iterable의 기능을 사용할 때 <strong>yield 키워드 뒤에 있는 값들을 순서대로 넘겨준다.</strong></p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">numberGen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 1, 2, 3이 순서대로 출력된다.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">numberGen</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">yield*</code> 표현식을 사용하면, 다른 generator 함수에서 넘겨준 값을 대신 넘겨줄 수도 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">numberGen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span><span class="o">*</span> <span class="nx">numberGen2</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">numberGen</span><span class="p">();</span>
  <span class="k">yield</span><span class="o">*</span> <span class="nx">numberGen</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 1, 2, 3, 1, 2, 3이 순서대로 출력된다.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">numberGen2</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>아래는 다양한 generator 함수이다. <code class="highlighter-rouge">yield</code> 키워드를 제외하면, generator 함수 내부의 동작 방식은 일반적인 함수와 별반 다르지 않다. 즉, 다른 함수에서 할 수 있는 일이라면 generator 함수 안에서도 모두 할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 등차수열 생성하기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">end</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="nx">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">end</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">step</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 피보나치 수열 생성하기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">count</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 하나의 항목을 계속 넘겨주기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">repeat</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">count</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 여러 요소를 반복해서 넘겨주기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">repeatMany</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Generator 함수를 사용할 때 주의할 점이 있다.</p>

    <ol>
      <li>Generator 함수로부터 생성된 iterable은 한 번만 사용될 수 있다.</li>
      <li>Generator 함수 내부에서 정의된 일반 함수에서는 <code class="highlighter-rouge">yield</code> 키워드를 사용할 수 없다.</li>
    </ol>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Generator 함수로부터 생성된 iterable은 한 번만 사용될 수 있다.</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">iter</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 잘 출력됩니다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// `iter`는 한 번 사용되었으므로, 이 코드는 실행되지 않는다.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Generator 함수 내부에서 정의된 일반 함수에서는 `yield` 키워드를 사용할 수 없다.</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">gen2</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 아예 문법 오류가 발생한다. (Unexpected token)</span>
  <span class="kd">function</span> <span class="nx">fakeGen</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">fakeGen</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h4 id="14-iterator-protocol">1.4 Iterator Protocol</h4>

<ol>
  <li>
    <p>Iterable Protocol과 Iterator Protocol은 서로 다른 것이다. 두 개를 구분해야 한다.</p>
  </li>
  <li>
    <p>iterable 객체는 iterable protocol을 만족한다. 즉, <code class="highlighter-rouge">Symbol.iterator</code> 속성에 <strong>특별한 형태의 함수가 저장되어 있다</strong>. Iterable protocol을 만족하려면, <code class="highlighter-rouge">Symbol.iterator</code> 속성에 저장되어 있는 함수는 <strong>iterator</strong> 객체를 반환해야 한다.</p>
  </li>
  <li>
    <p>Iterator 객체는 아래의 특별한 조건을 만족하는 객체이다. 아래 조건을 <strong>iterator protocol</strong>이라 한다.</p>

    <ol>
      <li>Iterator는 <code class="highlighter-rouge">next</code>라는 메소드를 갖는다.</li>
      <li><code class="highlighter-rouge">next</code> 메소드는 다음 두 속성을 갖는 객체를 반환해야 한다.
        <ol>
          <li><code class="highlighter-rouge">done</code> - 반복이 모두 끝났는지를 나타낸다.</li>
          <li><code class="highlighter-rouge">value</code> - 현재 순서의 값을 나타낸다.</li>
        </ol>
      </li>
    </ol>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 문자열은 iterable이므로 이로부터 iterator를 생성할 수 있다.</span>
<span class="kd">const</span> <span class="nx">strIterator</span> <span class="o">=</span> <span class="s1">'go'</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
<span class="nx">strIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: 'g', done: false }</span>
<span class="nx">strIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: 'o', done: false }</span>
<span class="nx">strIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: undefined, done: true }</span>
<span class="nx">strIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: undefined, done: true }</span>

<span class="c1">// generator 함수로부터 생성된 객체 역시 iterable이므로 이로부터 iterator를 생성할 수 있다.</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">genIterator</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">()[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
<span class="nx">genIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: 1, done: false }</span>
<span class="nx">genIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: 2, done: false }</span>
<span class="nx">genIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: undefined, done: true }</span>
<span class="nx">genIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: undefined, done: true }</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Iterable protocol과 iterator protocol을 모두 이해했다면, 이제 직접 iterable을 만들 수 있다. 아래는 앞의 예제에 있었던 <code class="highlighter-rouge">range</code> 함수를 generator 함수를 사용하지 않고 똑같이 구현한 결과이다. Generator 함수를 사용했을 때보다 훨씬 복잡한데, 이 때문에 iterator protocol을 직접 구현하는 대신 generator 함수를 사용하는 경우가 많다. 다만, <code class="highlighter-rouge">next</code> 메소드를 사용하면 iterable을 세부적으로 제어할 수 있으므로, iterator 대해서 알아둘 필요는 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">range</span><span class="p">(</span><span class="nx">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">end</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">,</span> <span class="nx">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 'range' 함수는 iterable을 반환한다.</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">currentValue</span><span class="p">:</span> <span class="nx">start</span><span class="p">,</span>
    <span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
      <span class="c1">// iterable의 'Symbol.iterator' 메소드는 iterator를 반환해야 한다.</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="na">next</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">currentValue</span> <span class="o">&lt;</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">currentValue</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">currentValue</span> <span class="o">+=</span> <span class="nx">step</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">{</span>
              <span class="na">done</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
              <span class="nx">value</span>
            <span class="p">}</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span>
              <span class="na">done</span><span class="p">:</span> <span class="kc">true</span>
            <span class="p">};</span>
          <span class="p">};</span>
        <span class="p">};</span>
      <span class="p">};</span>
    <span class="p">};</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>제너레이터 함수에 의해 반환된 제너레이터 객체는 iterable이고, iterable 객체의 Symbol.iterator 속성에 저장된 함수를 호출하면 iterator 객체가 반환된다.</p>
  </li>
  <li>
    <p>제너레이터 함수는 특이하게도 Symbol.iterator 프로퍼티에 저장된 함수가 자신과 같다. iterable인 동시에 iterator이다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">o</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">o</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="o">===</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration Protocol</a></p>
  </li>
</ol>

<p><br /></p>

<h4 id="15-generator와-iterator">1.5 Generator와 Iterator</h4>

<ol>
  <li>
    <p>Generator 함수로부터 만들어진 객체는 일반적인 iterable처럼 쓸 수 있지만, iterator와 관련된 특별한 성질을 갖고 있다.</p>
  </li>
  <li>
    <p>generator 함수로부터 만들어진 객체는 <strong>iterable protocol과 iterator protocol을 동시에 만족한다.</strong> 즉, <code class="highlighter-rouge">Symbol.iterator</code>를 통해 iterator를 생성하지 않고도 바로 <code class="highlighter-rouge">next</code>를 호출할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">genObj</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">genObj</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]().</span><span class="nx">next</span> <span class="o">===</span> <span class="nx">genObj</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>두 번째로, generator 함수 안에서 <code class="highlighter-rouge">return</code> 키워드를 사용하면 반복이 바로 끝나면서 <code class="highlighter-rouge">next</code> 메소드에서 반환되는 객체의 속성에 앞의 반환값이 저장된다. 다만, <code class="highlighter-rouge">return</code>을 통해 반환된 값이 반복 절차에 포함되지는 않는다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// generator 함수는 여기서 종료된다.</span>
  <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">iter</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>

<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: 1, done: false }</span>
<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: 2, done: true }</span>
<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: undefined, done: true }</span>

<span class="c1">// '1'만 출력된다.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">gen</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>generator 함수로부터 생성된 객체의 <code class="highlighter-rouge">next</code> 메소드에 인자를 주어서 호출하면, generator 함수가 멈췄던 부분의 <code class="highlighter-rouge">yield</code> 표현식의 결과값은 앞에서 받은 인자가 된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">received</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">received</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">iter</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">();</span>
<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">// { value: 1, done: false }</span>

<span class="c1">// 'hello'가 출력됩니다.</span>
<span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">);</span> <span class="c1">// { value: undefined, done: true }</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Generator 함수의 이런 성질은 비동기 프로그래밍을 위해 활용되기도 한다.</p>
  </li>
</ol>

<p><br /></p>

<h4 id="16-generator-examples">1.6 Generator Examples</h4>

<ol>
  <li>
    <p>다음은 iterable을 활용하는 몇 개의 generator 함수 예제이다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 각 항목을 변환한 후 넘겨주기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">map</span><span class="p">(</span><span class="nx">iterable</span><span class="p">,</span> <span class="nx">mapper</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">mapper</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 각 순서까지의 누적값을 넘겨주기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">iterable</span><span class="p">,</span> <span class="nx">reducer</span><span class="p">,</span> <span class="nx">initial</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">acc</span> <span class="o">=</span> <span class="nx">initial</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">acc</span> <span class="o">=</span> <span class="nx">reducer</span><span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">item</span><span class="p">);</span>
    <span class="k">yield</span> <span class="nx">acc</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 조건에 만족하는 항목만 넘겨주기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">iterable</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">iterable</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">predicate</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 여러 iterable을 연결하기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">concat</span><span class="p">(</span><span class="nx">iterables</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">iterable</span> <span class="k">of</span> <span class="nx">iterables</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">yield</span><span class="o">*</span> <span class="nx">iterable</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 앞쪽 몇 개의 항목만 넘겨주기</span>
<span class="kd">function</span><span class="o">*</span> <span class="nx">take</span><span class="p">(</span><span class="nx">iterable</span><span class="p">,</span> <span class="nx">count</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">iterator</span> <span class="o">=</span> <span class="nx">iterable</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `yield*`와는 다르게, iterator의 `next` 메소드를 이용하면 iterable의 일부만 가져올 수 있다.</span>
    <span class="kd">const</span> <span class="p">{</span><span class="nx">value</span><span class="p">,</span> <span class="nx">done</span><span class="p">}</span> <span class="o">=</span> <span class="nx">iterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">yield</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h3 id="2-클래스">2. 클래스</h3>

<h4 id="21-es2015-class">2.1 ES2015 Class</h4>

<ol>
  <li>문법이 아니라 동작방식의 측면에서 보면, ES2015 이전의 생성자와 ES2015의 클래스는 다음과 같은 차이점이 있다.
    <ol>
      <li>클래스는 <strong>함수로 호출될 수 없다.</strong> 즉, new 키워드를 붙이지 않으면 호출할 수 없다.</li>
      <li>클래스 선언은 <code class="highlighter-rouge">let</code>과 <code class="highlighter-rouge">const</code>처럼 <strong>블록 스코프</strong>에 선언되며, <strong>호이스팅(hoisting)</strong>이 일어나지 않는다.</li>
      <li>클래스의 메소드 안에서 <strong>super 키워드</strong>를 사용할 수 있다.</li>
    </ol>
  </li>
</ol>

<p><br /></p>

<h4 id="22-메소드-정의하기">2.2 메소드 정의하기</h4>

<ol>
  <li>
    <p>객체 리터럴의 문법과 마찬가지로, 임의의 표현식을 <strong>대괄호</strong>로 둘러싸서 메소드의 이름으로 사용할 수도 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">methodName</span> <span class="o">=</span> <span class="s1">'introduce'</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">({</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">})</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 아래 메소드의 이름은 'introduce'가 된다.</span>
  <span class="p">[</span><span class="nx">methodName</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`안녕하세요, 제 이름은 </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">입니다.`</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">Person</span><span class="p">({</span><span class="na">name</span><span class="p">:</span> <span class="s1">'윤아준'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">19</span><span class="p">}).</span><span class="nx">introduce</span><span class="p">());</span> <span class="c1">// 안녕하세요, 제 이름은 윤아준입니다.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Generator 메소드를 정의하려면, 메소드 이름 앞에 <code class="highlighter-rouge">*</code> 기호를 붙여주면 된다. 아래와 같이 <code class="highlighter-rouge">Symbol.iterator</code> 메소드를 generator로 정의해주면, 클래스의 인스턴스를 쉽게 iterable로 만들 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Gen</span> <span class="p">{</span>
  <span class="o">*</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 1, 2, 3이 차례대로 출력된다.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="k">new</span> <span class="nx">Gen</span><span class="p">())</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>아래는 Symbol.iterator에 제너레이터 함수를 정의함으로써 Gen의 인스턴스를 이터러블 객체로 구현한 예제이다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Gen</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">*</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">genObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Gen</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">n</span> <span class="k">of</span> <span class="nx">genObj</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h4 id="23-클래스-필드class-field">2.3 클래스 필드(Class Field)</h4>

<ol>
  <li>
    <p>클래스 블록 안에서 할당 연산자(<code class="highlighter-rouge">=</code>)를 이용해 인스턴스 속성을 지정할 수 있는 문법을 <strong>클래스 필드(class field)</strong>라고 한다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Counter</span> <span class="p">{</span>
  <span class="kr">static</span> <span class="nx">initial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// static class field</span>
  <span class="nx">count</span> <span class="o">=</span> <span class="nx">Counter</span><span class="p">.</span><span class="nx">initial</span><span class="p">;</span> <span class="c1">// class field</span>
  <span class="nx">inc</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Counter</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span><span class="p">());</span> <span class="c1">// 0</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span><span class="p">());</span> <span class="c1">// 1</span>

<span class="nx">Counter</span><span class="p">.</span><span class="nx">initial</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">new</span> <span class="nx">Counter</span><span class="p">().</span><span class="nx">count</span><span class="p">);</span> <span class="c1">// 10</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>클래스 필드는 아직 정식 표준으로 채택된 기능은 아니지만, 다음 표준에 채택될 것으로 확실시된다. 아직 이 기능을 구현한 브라우저는 없는 상태이고, Babel, TypeScript 등의 트랜스파일러를 통해 일부 기능을 사용할 수 있다.</p>
  </li>
</ol>

<p><br /></p>

<h4 id="24-클래스-필드와-this">2.4 클래스 필드와 this</h4>

<ol>
  <li>
    <p><code class="highlighter-rouge">class</code> 블록은 새로운 블록 스코프를 형성하고, 이 내부에서 사용된 <code class="highlighter-rouge">this</code>는 인스턴스 객체를 가리키게 된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">b</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">new</span> <span class="nx">MyClass</span><span class="p">().</span><span class="nx">b</span><span class="p">;</span> <span class="c1">// 1</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>이 성질을 이용하면, <strong>화살표 함수를 통해서 메소드를 정의할 수 있다.</strong> (화살표 함수 안에서의 <code class="highlighter-rouge">this</code> 키워드는 바로 바깥쪽 스코프에 존재하는 <code class="highlighter-rouge">this</code>와 같은 객체를 가리킨다.)</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">getA</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">new</span> <span class="nx">MyClass</span><span class="p">().</span><span class="nx">getA</span><span class="p">();</span> <span class="c1">// 1</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>이렇게만 보면 일반적인 메소드와 별로 차이가 없어 보이지만, 사실 동작방식 측면에서 굉장히 큰 차이점이 있다.</p>

    <ol>
      <li>일반적인 메소드는 클래스의 <code class="highlighter-rouge">prototype</code> 속성에 저장되는 반면, <strong>클래스 필드는 인스턴스 객체에 저장된다.</strong></li>
      <li>화살표 함수의 <code class="highlighter-rouge">this</code>는 호출 형태에 관계없이 항상 인스턴스 객체를 가리키게 된다.</li>
    </ol>
  </li>
  <li>
    <p>2번 성질때문에, <strong>메소드를 값으로 다루어야 할 경우</strong>에는 일반적인 메소드 대신 화살표 함수가 사용되는 경우가 종종 있다. 하지만, 1번 성질 때문에 <strong>상속</strong> 기능을 사용할 때 문제가 생긴다는 단점이 있다. 상속 기능을 활용할 예정에 있다면, 가급적 <strong>화살표 함수를 메소드로 사용하지 않는 것이 좋다.</strong></p>
  </li>
  <li>
    <p>메소드는 해당 클래스의 프로토타입 객체에 저장된다. 하지만 <strong>클래스필드는 생성될 인스턴스에 저장</strong>된다.</p>
  </li>
  <li>
    <p>클래스필드는 마치 생성자(constructor) 안에 들어있는 것처럼 동작한다.</p>
  </li>
  <li>
    <p>다음 예제에서 부모 클래스 <code class="highlighter-rouge">Parent</code>에서 클래스 필드로 정의한 <code class="highlighter-rouge">foo</code> 메소드는 자식 클래스 <code class="highlighter-rouge">Child</code>의 프로토타입 객체에 존재하지 않고 <code class="highlighter-rouge">Child</code>의 인스턴스인 <code class="highlighter-rouge">child</code>에 담기게 된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Parent'</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kd">class</span> <span class="nx">Child</span> <span class="kd">extends</span> <span class="nx">Parent</span> <span class="p">{</span>
  <span class="nx">boo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'Child'</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Child</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="c1">// Parent {}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span> <span class="c1">// Child {}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span> <span class="c1">// Child { foo: [Function], boo: [Function] }</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h3 id="3-dom-api">3. DOM API</h3>

<h4 id="31-html-데이터-속성">3.1 html 데이터 속성</h4>

<ol>
  <li>
    <p>엘리먼트에 대한 어떤 정보를 저장하고자 할 때 <code class="highlighter-rouge">data-*</code> 형식으로 데이터 속성을 사용한다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">data-*</code>의 *에는 원하는 어떤 값이든 사용할 수 있으며, 이때 이 값은 해당 엘리먼트의 <code class="highlighter-rouge">dataset</code> 프로퍼티를 통해 접근할 수 있다.</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">data-index=</span><span class="s">"1"</span> <span class="na">data-count=</span><span class="s">"2"</span> <span class="na">data-key=</span><span class="s">"3"</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;script&gt;</span>
  <span class="kd">const</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">'div'</span><span class="p">);</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">index</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">el</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span>
  <span class="nx">el</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">key</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h4 id="32-offsetparent-프로퍼티">3.2 offsetParent 프로퍼티</h4>

<ol>
  <li><code class="highlighter-rouge">offsetParent</code> 프로퍼티는 특정 엘리먼트의 position 속성으로 위치를 잡을 때 기준이 되는 요소를 나타낸다.</li>
</ol>

<p><br /></p>

<h4 id="33-getboundingclientrect">3.3 getBoundingClientRect()</h4>

<ol>
  <li><code class="highlighter-rouge">getBoundingClientRect()</code>를 통해 해당 엘리먼트의 크기 및 위치 정보를 확인할 수 있다.</li>
</ol>

<p><br /></p>

<h4 id="34-캡처링과-버블링">3.4 캡처링과 버블링</h4>

<ol>
  <li>버블링이 일어나는 이벤트도 있고, 일어나지 않는 이벤트(submit, focus, blur, change 등)도 있다.</li>
</ol>

<p><br /></p>

<h4 id="35-screenx-y--clientx-y">3.5 screenX, Y &amp; clientX, Y</h4>

<ol>
  <li><code class="highlighter-rouge">screenX</code>, <code class="highlighter-rouge">screenY</code>는 스크린을 기준으로 한 좌표를 나타낸다.</li>
  <li><code class="highlighter-rouge">clientX</code>, <code class="highlighter-rouge">clientY</code>는 브라우저 화면(뷰포트)의 가장 왼쪽 위를 기준으로 한 좌표를 나타낸다.</li>
</ol>

        <div class="page-footer">
          <div class="page-tag">
            <span>Tags:</span>
            
            <a href="/tags#패스트캠퍼스" class="tag">| 패스트캠퍼스</a>
            
            <a href="/tags#til" class="tag">| til</a>
            
            <a href="/tags#js" class="tag">| js</a>
            
            <a href="/tags#javascript" class="tag">| javascript</a>
            
          </div><!-- End Tags -->
          <div class="page-share">
            <span>Share:</span>
            <a href="https://twitter.com/intent/tweet?text=17년 12월 21일 수업 내용 정리&url=http://localhost:4000/learn/til/js-12/" title="Share on Twitter" rel="nofollow" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
            <a href="https://facebook.com/sharer.php?u=http://localhost:4000/learn/til/js-12/" title="Share on Facebook" rel="nofollow" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
            <a href="https://plus.google.com/share?url=http://localhost:4000/learn/til/js-12/" title="Share on Google+" rel="nofollow" target="_blank"><i class="fa fa-google" aria-hidden="true"></i></a>
          </div><!-- End Share -->
        </div>
        <section class="author-box">
  <img src="/assets/img/chayeoi-profile.jpg" alt="Chanyeon Kim" class="author-img">
  <div class="author-desc">
    <h2>Chanyeon Kim</h2>
    <p>자바스크립트를 무척 좋아하는 주니어 프론트엔드 개발자입니다. 현재 React.js, Vue.js, Node.js를 공부 중에 있습니다.</p>
    <ul>
      
        <li class="github"><a href="http://github.com/chayeoi" title="github 저장소" target="_blank"><i class="fa fa-github"></i></a></li>
      
      
        <li class="facebook"><a href="https://facebook.com/chayeoi" title="facebook 링크" target="_blank"><i class="fa fa-facebook"></i></a></li>
      
      
        <li class="instagram"><a href="https://instagram.com/chayeoi" title="instagram 링크" target="_blank"><i class="fa fa-instagram"></i></a></li>
      
      <!-- 
        <li class="email"><a href="mailto:y2oniary@gmail.com"><i class="fa fa-envelope-o"></i></a></li>
       -->
      <!-- 
        <li class="phone"><a href="tel:010-2650-5090"><i class="fa fa-phone"></i></a></li>
       -->
      
        <li class="website"><a href="http://chayeoi.creatorlink.net" title="포트폴리오 페이지" target="_blank"><i class="fa fa-globe"></i></a></li>
      
      <!-- 
        <li class="twitter"><a href="https://twitter.com/artemsheludko_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
       -->
    </ul>
  </div>
</section>
        <div class="recent-box">
  <h2 class="recent-title">Recent post</h2>
  <div class="recent-list">
    
      
        <a href="/learn/til/js-13/" class="recent-item" style="background: url(/assets/img/post-til.jpg) center no-repeat; background-size: cover;"><span>17년 12월 21일 수업 내용 정리</span></a>
      
    
      
        <a href="/learn/til/js-12/" class="recent-item" style="background: url(/assets/img/post-til.jpg) center no-repeat; background-size: cover;"><span>17년 12월 21일 수업 내용 정리</span></a>
      
    
      
        <a href="/learn/js/this/" class="recent-item" style="background: url(/assets/img/post-js.jpg) center no-repeat; background-size: cover;"><span>this 바인딩 규칙</span></a>
      
    
      
        <a href="/learn/etc/jekyll/" class="recent-item" style="background: url(/assets/img/post-etc.jpg) center no-repeat; background-size: cover;"><span>Jekyll 블로그 만들기</span></a>
      
    
  </div>
</div> <!-- End Recent-Box -->

        <section class="comment-area">
  <h2 class="comment-heading-invisible">댓글</h2n>
  <div class="comment-wrapper">
    
    <div id="disqus_thread" class="article-comments"></div>
    <script>
      (function() {
          var d = document, s = d.createElement('script');
          s.src = '//y2oniary.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
  </div>
</section> <!-- End Comment Area -->

      </div>
    </div> <!-- End Wrapper -->
  </article>
  <div class="search-box">
  <div class="wrapper">
    <div class="search-grid">
      <form class="search-form">
        <div id="search-container">
          <input type="text" id="search-input" class="search" placeholder="Search">
        </div>
      </form>
      <ul id="results-container" class="results-search"></ul>
      <div class="icon-close-container">
        <span class="search-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
      </div>
    </div>
  </div>
</div>

  <footer class="main-footer">
  <div class="copyright">
    <p>2018 &copy; Chanyeon Kim</p>
  </div>
</footer> <!-- End Footer -->

</div>

  <!-- JS -->
<script src="/assets/js/jquery-3.2.1.min.js"></script>
<script src="/assets/js/jekyll-search.js"></script>
<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
    noResultsText: 'No results found',
    fuzzy: false,
    exclude: ['Welcome']
  });
</script>
<script src="/assets/js/main.js"></script>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

</body>
</html>
