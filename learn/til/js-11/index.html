<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="utf-8">
	<title>17년 12월 21일 수업 내용 정리 - Oh My Charlie</title>
	<meta name="description" content="패스트캠퍼스 프론트엔드 스쿨 수업 내용 정리 (js)">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta property="og:image" content="">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-touch-icon-114x114.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#311e3e">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#311e3e">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#311e3e">
	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">
	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>
  <div class="flex-container">
  <header class="main-header">
  <div class="header-wrapper">
    <div class="header-flex">
      <h1 class="logo"><a href="/">Oh My Charlie</a></h1>
      <div class="menu-icon-container">
        <span class="menu-icon"><i class="fa fa-bars" aria-hidden="true"></i></span>
      </div>
      <nav class="main-nav">
        <h2 class="nav-heading-invisible">네비게이션</h2>
        <span class="menu-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
        <ul>
          <li><a href="/">Home</a></li>
          <li><a href="/about">About</a></li>
          <li><a href="/html5">HTML5</a></li>
          <li><a href="/css3">CSS3</a></li>
          <li><a href="/js">Javascript</a></li>
          <li><a href="/til">Today I Learned</a></li>
        </ul>
      </nav>
      <div class="search-icon-container">
        <span class="search-icon"><a><i class="fa fa-search" aria-hidden="true"></i></a></span>
      </div>
    </div>
  </div>
</header> <!-- End Header -->

  <article class="article-page">
    <div class="page-image">
      <div class="cover-image" style="background: url(/assets/img/post-til.jpg) center no-repeat; background-size: cover;"></div>
    </div>
    <div class="wrapper">
      <div class="page-content">
        <div class="header-page">
          <h1 class="page-title">17년 12월 21일 수업 내용 정리</h1>
          <div class="page-date"><time datetime="2017-12-21 00:00:00 +0900">2017, Dec 21</time></div>
        </div>
        <h1 id="today-i-learned">Today I Learned</h1>

<blockquote>
  <p>패스트캠퍼스 김승하 강사님의 수업 내용 중 정확히 몰랐거나 헷갈렸던  내용을 모두 발췌함.</p>
</blockquote>

<h2 id="4-day">4 Day</h2>

<h3 id="1-함수형-프로그래밍">1. 함수형 프로그래밍</h3>

<h4 id="11-클로저closure">1.1 클로저(Closure)</h4>

<ol>
  <li>
    <p>때때로 클로저의 성질은 <strong>데이터를 숨기고 정해진 방법을 통해서만 데이터에 접근할 수 있도록 제한</strong>을 두는 데 활용되기도 한다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">makeCounter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// `x`를 직접 변경할 수 있는 방법이 없다!</span>

<span class="kd">const</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nx">makeCounter</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">());</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">());</span> <span class="c1">// 2</span>
</code></pre></div>    </div>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">personFactory</span><span class="p">(</span><span class="nx">initialAge</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">age</span> <span class="o">=</span> <span class="nx">initialAge</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">getOlder</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">age</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">getAge</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">age</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="c1">// `age`를 직접 변경할 수 있는 방법이 없다!</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>근래의 JavaScript 디버거는 클로저에 어떤 값이 들어있는지를 보여주는 기능을 포함하고 있다.</p>
  </li>
</ol>

<p><br /></p>

<h4 id="12-화살표-함수와-고차-함수">1.2 화살표 함수와 고차 함수</h4>

<ol>
  <li>
    <p>화살표 함수 문법을 이용하면, 적은 양의 코드만 사용해서 고차 함수를 만들 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">makeCounter</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="o">++</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">counter</span> <span class="o">=</span> <span class="nx">makeCounter</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">());</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">());</span> <span class="c1">// 2</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h4 id="13-재귀-함수recursive-function">1.3 재귀 함수(Recursive Function)</h4>

<ol>
  <li>
    <p>함수 내부에서 <strong>자기 자신을 호출하는 함수</strong>를 <strong>재귀 함수(recursive function)</strong>라고 부른다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">func</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>대부분의 루프는 재귀함수를 통해 다시 구현될 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 루프로 구현된 팩토리얼</span>
<span class="kd">function</span> <span class="nx">factorialLoop</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">*=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 재귀 함수로 구현된 팩토리얼</span>
<span class="kd">function</span> <span class="nx">factorialRec</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">factorialRec</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// factorialRec(4)의 실행 결과</span>
<span class="c1">// 4 * f(3)</span>
<span class="c1">//	   3 * f(2)</span>
<span class="c1">//		   2 * f(1)</span>
<span class="c1">//			   1</span>
<span class="c1">// 이전까지 f(3), f(2), f(1)의 결과를 알 수 없으므로 f(1)부터 순차적으로 계산하기 시작한다.</span>
<span class="c1">// ① f(1)의 결과로 1이 반환된다.</span>
<span class="c1">// ② f(2)의 결과로 2가 반환된다.</span>
<span class="c1">// ③ f(3)의 결과로 6이 반환된다.</span>
<span class="c1">// ④ f(4)의 결과로 24가 반환된다.</span>
<span class="c1">// 계산된 결과가 순차적으로 콜 스택에 쌓인다.</span>
</code></pre></div>    </div>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 루프로 구현된 피보나치 수</span>
<span class="kd">function</span> <span class="nx">fiboLoop</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 재귀 함수로 구현된 피보나치 수</span>
<span class="kd">function</span> <span class="nx">fiboRec</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="p">?</span> <span class="mi">0</span> <span class="p">:</span>
    <span class="nx">n</span> <span class="o">===</span> <span class="mi">1</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span>
    <span class="nx">fiboRec</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fiboRec</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>거의 모든 재귀함수는 계속적으로 진행할지 말지에 대한 조건을 포함한다. 또한 다음 함수 호출 시에 넘겨지는 인자를 변경하는 부분을 갖는다.</p>
  </li>
  <li>
    <p>위에서 볼 수 있듯이, 재귀 함수를 사용하면 루프를 사용했을 때보다 <strong>코드의 의미가 명확해지고 코드의 길이를 줄일 수 있다</strong>는 장점이 있다.</p>
  </li>
  <li>
    <p>재귀함수를 사용하면 기존 방식보다 알고리즘 효율을 효과적으로 높일 수 있다.</p>
  </li>
</ol>

<p><br /></p>

<h4 id="14-분할-정복divide-and-conquer">1.4 분할 정복(Divide and Conquer)</h4>

<ol>
  <li>
    <p>분할 정복(divide and conquer)은 <strong>문제를 작은 부분 문제로 나누어서 푼 뒤, 그 결과를 합치는 식</strong>으로 알고리즘을 작성하는 기법이며, 재귀 함수가 활용되는 대표적인 사례이다. 바로 위의 <code class="highlighter-rouge">fiboRec</code> 역시 분할 정복의 일종이라 할 수 있다.</p>
  </li>
  <li>
    <p>피보나치 수열을 예로 들어 설명하면 다음과 같다.</p>

    <ol>
      <li>피보나치 수열에서 4항의 값을 얻기 위해 3항, 2항의 값을 얻는다.</li>
      <li>3항, 2항의 값을 얻기 위해 각각 2항과 1항, 1항과 0항의 값을 얻는다.</li>
    </ol>
  </li>
  <li>
    <p>분할 정복 기법을 활용하는 알고리즘 중 대표적인 예로 <strong>병합 정렬(merge sort)</strong>을 들 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 입력된 배열의 길이가 1 이하이면 더 이상 재귀 호출을 하지 않는다.</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>

  <span class="c1">// 배열을 절반으로 잘라 두 개의 작은 배열로 분할하고,</span>
  <span class="c1">// 두 작은 배열에 대해 재귀 호출을 수행한다.</span>
  <span class="kd">const</span> <span class="nx">slicer</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">slicer</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">slicer</span><span class="p">));</span>

  <span class="c1">// 'arr1', 'arr2'는 이미 정렬되어있는 상태이므로,</span>
  <span class="c1">// 이 성질을 이용해 두 배열을 정렬되어있는 큰 배열로 합칠 수 있다.</span>
  <span class="kd">const</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr2</span><span class="p">[</span><span class="nx">j</span><span class="p">]);</span>
      <span class="nx">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 큰 배열을 반환한다.</span>
  <span class="k">return</span> <span class="nx">newArr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>병합 정렬이 선택 정렬과 비교했을 때 훨씬 빠르다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">slicer</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">slicer</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">slicer</span><span class="p">));</span>
  <span class="kd">const</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr1</span><span class="p">.</span><span class="nx">length</span> <span class="o">||</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">arr2</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">arr2</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr2</span><span class="p">[</span><span class="nx">j</span><span class="p">]);</span>
      <span class="nx">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr1</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
      <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">newArr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">selectionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">minIndex</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">arr</span><span class="p">[</span><span class="nx">minIndex</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">50000</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">null</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">);</span>

<span class="c1">// mergeSort: 71ms</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">time</span><span class="p">(</span><span class="s1">'mergeSort'</span><span class="p">);</span>
<span class="nx">mergeSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">timeEnd</span><span class="p">(</span><span class="s1">'mergeSort'</span><span class="p">);</span>

<span class="c1">// selectionSort: 2104ms</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">time</span><span class="p">(</span><span class="s1">'selectionSort'</span><span class="p">);</span>
<span class="nx">selectionSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">timeEnd</span><span class="p">(</span><span class="s1">'selectionSort'</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>재귀 함수는 알고리즘을 간결하고 명확하게 서술할 수 있게 해 주지만, 사용할 때 주의해야 할 점이 몇 가지 있다.</p>

    <ol>
      <li>
        <p>재귀 함수가 실행되는 동안에는 <strong>종료되지 않은 함수</strong>가 아주 많이 생기게 되므로, 코드의 실행 속도가 느려지거나 컴퓨터 메모리에 큰 부담을 줄 수 있다. 이 때문에 대부분의 JavaScript 구동 환경에서는 <strong>특정 깊이 이상의 재귀 호출이 일어날 수 없도록 제한</strong>을 두고 있다. Chrome 브라우저의 경우 대약 10000번 정도의 재귀 호출이 일어나면 아래와 같은 에러를 발생시킨다(이 제한을 뛰어넘을 수 있게 해주는 ‘tail call optimisation’이라는 기능이 ES2015 명세에 포함되었지만, 사파리 외에는 아직 이 기능을 구현한 브라우저가 없는 상태이다). 만약 재귀 호출에 대한 제한 때문에 원하는 작업을 수행할 수 없게 됐다면, 재귀 함수 대신 <strong>루프 혹은 스택(stack)</strong>을 사용해서 코드를 재작성하면 된다.</p>

        <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">factorialRec</span><span class="p">(</span><span class="mi">20000</span><span class="p">);</span> <span class="c1">// RangeError: Maximum call stack size exceeded</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>또한, 주의하지 않으면 쓸데없는 재귀 호출이 아주 많이 일어나게 될 수 있다. 위의 피보나치 수를 구하는 예제에서, 100 번째 피보나치 수를 구하기 위해 <code class="highlighter-rouge">fiboRec(100)</code>을 호출하면, <code class="highlighter-rouge">fiboRec(90)</code>는 89번, <code class="highlighter-rouge">fiboRec(80)</code>은 10946번, <code class="highlighter-rouge">fiboRec(70)</code>은 1346269번… 이런 식으로 <strong>같은 인자에 대한 호출이 쓸데없이 많이 일어나게 된다.</strong> 더군다나 <code class="highlighter-rouge">fiboRec</code> 함수는 재귀 호출이 깊이가 깊어질 수록 같은 호출 횟수가 기하급수적으로 증가하게 되므로, 인자의 크기가 조금만 커져도 답을 구할 수 없을 정도로 함수의 실행 시간이 길어지게 된다. 사실 <code class="highlighter-rouge">fiboRec(70)</code>을 한 번 호출했다면 우리는 이미 <strong>그 답을 알고 있으므로 다시 계산할 필요가 없다.</strong> 그래서, 일단 한 번 구해놓은 답은 별도의 저장소에 기억하고, 후에 같은 인자로 함수가 호출되면 이전에 계산해놓았던 답을 바로 반환하는 식으로 재귀 함수를 작성할 수 있습니다. 이런 방식을 통해 함수의 호출 횟수를 극단적으로 줄일 수 있다. 이런 기법을 <strong>메모이제이션(memoization)</strong>이라고 부른다. 위의 <code class="highlighter-rouge">fiboRec</code> 함수를 메모이제이션 기법을 통해 아래와 같이 재작성할 수 있다.</p>
      </li>
    </ol>

    <p><br /></p>

    <blockquote>
      <h5 id="순수-함수">순수 함수</h5>

      <p>단, 메모이제이션 기법은 ‘반환값이 오로지 주어진 인자에 의해서만 결정되는 함수’에 대해서만 적용할 수 있다. 이와 같은 함수를 순수 함수(pure function)라고 부른다.</p>

      <h5 id="iife">IIFE</h5>

      <p><code class="highlighter-rouge">fiboRecMemoized</code>를 만들 때, 클로저에 <code class="highlighter-rouge">memo</code>라는 저장소를 숨기기 위해서 화살표 함수 리터럴을 통해 함수를 만든 후 이 함수를 바로 호출했다. 이렇게 함수 리터럴을 바로 호출하는 기법을 IIFE(Immediately Invoked Function Expression) 혹은 ‘즉시 호출 함수 표현식’이라고 부른다. 이전에는 전역 스코프를 오염시키지 않고 변수를 선언하려는 목적에서 IIFE가 널리 사용되었지만, CommonJS 혹은 ES2015 모듈이 같은 역할을 해 줄 수 있기 때문에 최근에는 IIFE가 자주 사용되지는 않는다.</p>
    </blockquote>
  </li>
</ol>

<p><br /></p>

<h3 id="2-연산자-더-알아보기">2. 연산자 더 알아보기</h3>

<h4 id="21-값을-비교하는-여러가지-방법">2.1 값을 비교하는 여러가지 방법</h4>

<ol>
  <li>JavaScript에서는 두 값이 같은지를 비교하기 위해 아래 세 가지 방법을 사용할 수 있다.
    <ol>
      <li><code class="highlighter-rouge">==</code>, <code class="highlighter-rouge">!=</code></li>
      <li><code class="highlighter-rouge">===</code>, <code class="highlighter-rouge">!==</code></li>
      <li><code class="highlighter-rouge">Object.is</code></li>
    </ol>
  </li>
</ol>

<p><br /></p>

<h5 id="211-추상적-동일성abstract-equality">2.1.1 추상적 동일성((Abstract Equality)</h5>

<ol>
  <li><code class="highlighter-rouge">==</code> 연산자는 두 피연산자의 타입이 다를 때는 <strong>타입을 변환</strong>한 후 비교한다. 두 피연산자의 타입이 같다면 <code class="highlighter-rouge">===</code> 연산자와 같은 방식으로 동작한다.</li>
  <li>null check를 할 때 만큼은 유용하게 사용된다. <code class="highlighter-rouge">==</code> 연산자는 <code class="highlighter-rouge">null</code> 과 <code class="highlighter-rouge">undefined</code>를 동일하지만, 이 두 값을 다른 어떤 값과도 동일하지 않은 것으로 취급하기 때문이다.</li>
</ol>

<p><br /></p>

<h5 id="212-엄격한-동일성strict-equality">2.1.2 엄격한 동일성(Strict Equality)</h5>

<ol>
  <li>
    <p><code class="highlighter-rouge">===</code>, <code class="highlighter-rouge">!==</code> 연산자는 <strong>두 피연산자의 타입이 다른 경우 무조건 false를 반환한다.</strong> 따라서 <code class="highlighter-rouge">==</code>, <code class="highlighter-rouge">!=</code> 연산자와는 달리, 서로 다른 타입의 피연산자에 대해서도 안심하고 사용할 수 있다.</p>
  </li>
  <li>
    <p>다만, number 타입에 대한 비교를 할 때에는 다음과 같이 특이한 동작을 한다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// '===' 연산에서, 'NaN'은 number 타입의 모든 값과 다릅니다. 이는 자기 자신에 대해서도 마찬가지이다.</span>
<span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span><span class="p">;</span> <span class="c1">// false</span>

<span class="c1">// '0'과 '-0'은 서로 다른 값이지만, '===' 연산은 이 둘을 같은 것으로 취급한다.</span>
<span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h5 id="213-objectis">2.1.3 Object.is</h5>

<ol>
  <li>
    <p><code class="highlighter-rouge">Object.is</code> 정적 메소드는 두 인자가 <strong>정말로 같은 값인지</strong>를 검사한다. 아래의 두 예외를 제외하고는 <code class="highlighter-rouge">===</code> 연산자와 같은 방식으로 동작한다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// false</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h4 id="22-spread-syntax">2.2 Spread Syntax</h4>

<ol>
  <li>
    <p>ES2015에서 배열을 다른 배열에 쉽게 삽입할 수 있게 해 주는 spread 문법이 추가되었다. 나머지 매개변수(rest parameters) 문법과 같은 기호인 <code class="highlighter-rouge">...</code>가 사용되지만, 그 의미는 다르다.</p>
  </li>
  <li>
    <p>객체에 대한 spread 문법은 아직 정식 표준으로 확정되지는 않았지만, 후보(candidate) 단계의 표준으로 <a href="http://kangax.github.io/compat-table/esnext/">이미 여러 브라우저에 구현이 되어 있다.</a></p>
  </li>
  <li>
    <p>Spread 문법을 통해 배열 리터럴의 중간에 다른 배열을 이어붙일 수 있다. 이 때, <code class="highlighter-rouge">arr1</code> 안에 있는 요소들이 <code class="highlighter-rouge">arr2</code> 안으로 <strong>복사</strong>된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...</span><span class="nx">arr1</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span> <span class="c1">// [1, 2, 3, 4, 5]</span>

<span class="c1">// 이전에는 같은 작업을 하기 위해 'Array.prototype.concat' 메소드를 사용했다.</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">arr1</span><span class="p">).</span><span class="nx">concat</span><span class="p">([</span><span class="mi">5</span><span class="p">])</span> <span class="c1">// [1, 2, 3, 4, 5]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>또한 배열 리터럴 안에 다른 요소를 써주지 않음으로써, 배열 전체를 쉽게 복사할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">arr</span><span class="p">];</span>

<span class="c1">// 이전에는 같은 작업을 하기 위해 'Array.prototype.slice' 메소드를 사용했다.</span>
<span class="nx">arr1</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>다만, 이 때 역시 깊은 복사가 아니라 <strong>얕은 복사</strong>가 이루어진다.</p>
  </li>
  <li>
    <p>Spread 문법은 함수 호출 시에도 사용할 수 있다. 이 때 배열의 모든 요소를 함수의 인자로 넘긴다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

<span class="c1">// 아래 코드는 'Math.max(1, 2, 3, 4, 5)'와 동일하다.</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">arr</span><span class="p">);</span> <span class="c1">// 5</span>

<span class="c1">// 이전에는 같은 작업을 하기 위해 'Function.prototype.apply' 메소드를 사용했다.</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">arr</span><span class="p">);</span> <span class="c1">// 5</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>아직 정식 표준에 포함되지는 않았지만, 객체에 대해서도 spread 문법을 사용할 수 있다. 이 때 자기 자신의(own) 열거 가능한(enumerable) 속성만을 복사한다. 아직 몇몇 브라우저에 이 문법이 구현되어 있지 않기 때문에, 이 문법을 사용하려면 <a href="http://babeljs.io/docs/plugins/transform-object-rest-spread/">Babel 플러그인</a> 혹은 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#object-spread-and-rest">TypeScript</a> 등의 트랜스파일러를 사용해야 한다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span><span class="na">prop</span><span class="p">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="kd">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{...</span><span class="nx">obj1</span><span class="p">};</span>

<span class="c1">// 이전에는 같은 작업을 하기 위해 'Object.assign' 정적 메소드를 사용했다.</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">obj1</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h4 id="23-분해-대입-destructuring-assignment">2.3 분해 대입 (Destructuring Assignment)</h4>

<h5 id="231-배열의-분해-대입">2.3.1 배열의 분해 대입</h5>

<ol>
  <li>
    <p>다음과 같이, 변수의 선언과 동시에 배열의 요소를 해당 변수에 대입할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="c1">// 1 2 3</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>만약 요소의 순서와 일치하는 변수가 좌측 목록에 들어있지 않으면, 해당 요소는 무시된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 여기서 `2`, `4`는 무시된다.</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">,</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="c1">// 1 3</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>이미 선언된 변수에 대해서도 분해대입을 할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 1 2</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>배열이 중첩되어 있으면, 해당 배열에 대해서도 분해대입을 할 수 있다. 이 때에는 등호의 좌측에서도 배열이 중첩된 것처럼 써주면 된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">[</span><span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span> <span class="c1">// 1 2 3 4</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>만약 분해대입 시 배열의 뒷부분을 새로운 배열로 만들고 싶다면, 해당 위치의 변수 앞에 <code class="highlighter-rouge">...</code>을 붙여주면 된다. 나머지 매개변수(rest parameter)에서와 같이, <code class="highlighter-rouge">...</code>은 맨 마지막 요소에만 붙을 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">...</span><span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// [3, 4, 5]</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h5 id="232-객체-분해-대입">2.3.2 객체 분해 대입</h5>

<ol>
  <li>
    <p>다음과 같이, 변수의 선언과 동시에 객체의 속성을 해당 변수에 대입할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="nx">prop1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="nx">prop2</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prop1</span><span class="p">,</span> <span class="nx">prop2</span><span class="p">);</span> <span class="c1">// 1 2</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>좌측 객체 표기에서 속성값 부분을 생략하면, 속성 이름 부분이 곧 새 변수의 이름이 된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 1 2</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>만약 어떤 속성의 이름과 같은 이름을 갖는 변수가 좌측에 들어있지 않으면, 해당 속성은 무시된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 여기서 'b'는 무시된다.</span>
<span class="kd">const</span> <span class="p">{</span><span class="nx">a</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>이미 선언된 변수에 대해서도 분해대입을 할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">;</span>
<span class="c1">// 문장이 여는 중괄호('{')로 시작되면 이는 '블록'으로 간주되므로,</span>
<span class="c1">// 아래와 같이 분해대입을 할 때는 식 전체를 괄호로 둘러싸주어야 한다.</span>
<span class="p">({</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 1 2</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>객체가 중첩되어 있으면, 해당 객체에 대해서도 분해대입을 할 수 있다. 이 때에는 등호의 좌측에서도 객체가 중첩된 것처럼 써주면 된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="nx">a</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="p">{</span><span class="nx">c</span><span class="p">}}</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="p">{</span><span class="na">c</span><span class="p">:</span> <span class="mi">2</span><span class="p">}};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="c1">// 1 2</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>배열과 객체가 함께 중첩되어 있는 경우에서도 분해대입이 가능하다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span>
  <span class="na">arr</span><span class="p">:</span> <span class="p">[</span>
    <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">c</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">arr</span><span class="p">:</span> <span class="p">[</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">c</span> <span class="p">:</span> <span class="mi">3</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="c1">// 1 2 3</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h5 id="233-객체의-나머지-속성object-rest-properties">2.3.3 객체의 나머지 속성(Object Rest Properties)</h5>

<ol>
  <li>
    <p>만약 분해대입 시 무시된 속성들을 가지고 새로운 객체를 만들고 싶다면, <code class="highlighter-rouge">...</code>을 붙여주면 된다. 나머지 매개변수(rest parameter)에서와 같이, <code class="highlighter-rouge">...</code>은 맨 마지막에만 붙을 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">{</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">d</span><span class="p">:</span> <span class="mi">4</span><span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rest</span><span class="p">);</span> <span class="c1">// { c: 3, d: 4 }</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>아직 몇몇 브라우저에 이 문법이 구현되어 있지 않기 때문에, 이 문법을 사용하려면 <a href="http://babeljs.io/docs/plugins/transform-object-rest-spread/">Babel 플러그인</a> 혹은 <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#object-spread-and-rest">TypeScript</a> 등의 트랜스파일러를 사용해야 한다.</p>
  </li>
</ol>

<p><br /></p>

<h5 id="234-분해-대입의-기본값">2.3.4 분해 대입의 기본값</h5>

<ol>
  <li>
    <p>분해대입 시, 만약 좌측 변수의 위치에 해당하는 값이 우측의 배열 혹은 객체에 존재하지 않으면 거기에는 대입이 일어나지 않는다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">;</span>

<span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>이 때에 좌측 변수에 기본으로 대입될 값을 미리 지정해둘 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 'c' 위치에는 대입될 값이 없으므로, 기본값인 '3'이 대신 사용됩니다.</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// 3</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>이 동작은 객체에 대한 분해대입에서도 적용된다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="p">{</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// 3</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h5 id="235-매개변수에서의-분해대입">2.3.5 매개변수에서의 분해대입</h5>

<ol>
  <li>
    <p>함수의 매개변수에서도 분해대입을 할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">func</span><span class="p">({</span><span class="nx">prop</span><span class="p">,</span> <span class="na">array</span><span class="p">:</span> <span class="p">[</span><span class="nx">item1</span><span class="p">,</span> <span class="nx">item2</span><span class="p">,</span> <span class="nx">item3</span> <span class="o">=</span> <span class="mi">4</span><span class="p">]})</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">prop</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item1</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item2</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item3</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 1, 2, 3, 4가 차례대로 출력된다.</span>
<span class="nx">func</span><span class="p">({</span><span class="na">prop</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]});</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<blockquote>
  <h5 id="레이블-구문">레이블 구문</h5>

  <ol>
    <li>반복문에 레이블을 붙이고, break나 continue 구문을 사용해 반복문의 어느 위치에서 작업을 멈추고 어느 위치에서 다시 수행할지를 알려줄 수 있다.</li>
    <li>자바스크립트에는 goto 구문이 없다는 것에 주의. break나 continue에서만 레이블을 사용할 수 있다.</li>
    <li>strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)  코드에서 “let”을 레이블 이름으로 사용할 수 없다. <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"><code class="highlighter-rouge">SyntaxError</code></a>를 발생시킨다. (let은 허용되지 않는 식별자이다.)</li>
    <li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/label">MDN 참고</a></li>
  </ol>
</blockquote>

<p><br /></p>

<h3 id="3-내장-객체-및-생성자">3. 내장 객체 및 생성자</h3>

<h4 id="31-json">3.1 JSON</h4>

<ol>
  <li>
    <p>프로그래밍을 하다 보면 ‘프로그래밍 언어에서 사용하는 자료구조’를 보조기억장치에 <strong>저장</strong>하거나, 혹은 네트워크를 통해 <strong>전송</strong>해야 할 일이 생긴다. 이 때 자료구조를 <strong>그대로</strong> 저장/전송할 수는 없으니, 저장/전송 가능한 형태로 변환하는 절차가 필요하다. 이 절차를 일러 <strong>직렬화(serialization)</strong>라고 한다. 반대로, 직렬화된 데이터를 프로그래밍 언어에서 다시 사용할 수 있도록 변환해주는 절차를 <strong>역직렬화(deserialization)</strong>라고 한다.</p>
  </li>
  <li>
    <p><strong>JSON(JavaScript Object Notation)</strong>은 웹의 세계에서는 가장 많이 사용되는 직렬화 형식이다. 그 이름이 말해주듯이, <strong>JavaScript 객체와 유사한 표기법</strong>을 사용하는 <strong>텍스트</strong>를 통해 복잡한 자료구조를 나타낸다.</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"key"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"arr"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w">
  </span><span class="s2">"nullProp"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>JSON은 언어에 관계없이 사용할 수 있는 직렬화 형식이고, 실제로 많은 프로그래밍 언어들이 JSON 관련 기능을 내장하고 있다.</p>
  </li>
  <li>
    <p>JavaScript 역시 JSON 관련 기능을 내장하고 있다. 같은 이름의 <code class="highlighter-rouge">JSON</code> 내장 객체의 메소드를 통해 직렬화와 역직렬화를 할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// `JSON.stringify`로 직렬화를 할 수 있습니다.</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
  <span class="na">key</span><span class="p">:</span> <span class="s1">'value'</span><span class="p">,</span>
  <span class="na">arr</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
  <span class="na">nullProp</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="na">undefinedProp</span><span class="p">:</span> <span class="kc">undefined</span> <span class="c1">// 값이 `undefined`인 속성은 직렬화 과정에서 제외됩니다.</span>
<span class="p">});</span> <span class="c1">// '{"key":"value","arr":[1,2,3],"nullProp":null}'</span>

<span class="c1">// `JSON.parse`로 역직렬화를 할 수 있습니다.</span>
<span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'{"key":"value","arr":[1,2,3],"nullProp":null}'</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>또다른 저장 포맷 형식으로 YAML, XML 등이 있다.</p>
  </li>
  <li>
    <p>JSON을 직접 편집해야 할 때는 <strong>JSON이 JavaScript가 아니라는 사실에 주의</strong>해야 한다. JavaScript 객체와 유사한 표기법을 비슷하게 빌려 쓴 것 뿐이다. 따라서 Javascript 메소드를 사용할 수 없다.</p>

    <ol>
      <li>속성 이름은 꼭 쌍따옴표를 둘러주어야 한다. 홑따옴표도 안 된다.</li>
      <li><code class="highlighter-rouge">Map</code>, <code class="highlighter-rouge">Set</code>, <code class="highlighter-rouge">Date</code>, <code class="highlighter-rouge">Error</code>, <code class="highlighter-rouge">RegExp</code>, <code class="highlighter-rouge">Function</code>, <code class="highlighter-rouge">Promise</code>와 같이 특별한 동작방식을 가지는 객체들을 제대로 표현할 수 없다.</li>
      <li><code class="highlighter-rouge">undefined</code>, <code class="highlighter-rouge">NaN</code>, <code class="highlighter-rouge">Infinity</code>과 같은 값을 표현할 수 없다.</li>
      <li>주석을 쓸 수 없다.</li>
    </ol>
  </li>
</ol>

<p><br /></p>

<h4 id="32-date">3.2 Date</h4>

<ol>
  <li>Date 객체는 기능이 부족한 편이기 때문에, 실무에서 다른 라이브러리와 함께 쓰이는 경우가 많다. 그렇다 하더라도 관련 라이브러리를 잘 쓰기 위해서는 우선 Date 객체를 잘 이해해야 한다.</li>
  <li>Date 객체를 사용하기 위해서 일단 아래의 개념들을 알아둘 필요가 있다.
    <ol>
      <li><strong>협정 세계시 (UTC)</strong> - 지구 상의 여러 지역에서는 <strong>시간대(timezone)</strong>와 <strong>일광 절약 시간제(DST)</strong>에 따라 서로 다른 시각을 사용한다. 이 때문에 발생하는 혼동을 피하기 위해 <strong>위치 및 DST의 사용 여부와 상관 없이 같은 기준으로</strong> 시각을 다룰 필요가 있는데, 이 때 사용되는 것이 협정 세계시(UTC)이다. UTC가 만들어지기 이전에는 <strong>그리니치 평균시(GMT)</strong>라는 용어가 널리 쓰였다. 또한 조금씩 느려지는 지구 자전 속도에 맞추기 위해 UTC에는 가끔씩 <strong>윤초(leap second)</strong>가 추가되기도 한다. GMT를 쓰다가 윤초라는 개념을 추가해서 UTC를 만들었는데, 간혹 두 용어가 혼용되기도 한다.</li>
      <li><strong>유닉스 시간</strong> - 컴퓨터에서는 시간 데이터를 편하게 다루기 위해서 유닉스 시간이라는 특별한 단위를 사용한다. 유닉스 시간은 UTC 기준 1970년 1월 1일 0시 0분 0초부터 경과한 시간을 초 단위의 정수로 나타낸다. 예를 들어, 한국 시간대의 <code class="highlighter-rouge">2017-12-10 12:26:11</code>라는 시간을 유닉스 시간으로 나타내면 <code class="highlighter-rouge">1512876371</code>이 된다. 유닉스 시간은 POSIX 시간 또는 <strong>Epoch 시간</strong>이라는 이름으로 불리기도 한다.</li>
    </ol>
  </li>
</ol>

<p><br /></p>

<h5 id="321-date-객체의-생성">3.2.1 Date 객체의 생성</h5>

<ol>
  <li>Date` 생성자는 아래와 같은 방법으로 사용할 수 있다.
    <ol>
      <li><code class="highlighter-rouge">new Date()</code> - <strong>현재 시각</strong>을 나타내는 Date 객체를 반환한다.</li>
      <li><code class="highlighter-rouge">new Date(value)</code> - <code class="highlighter-rouge">value</code>가 정수인 경우, 이를 <strong>밀리초 단위</strong>의 유닉스 시간으로 간주해서 이에 해당하는 Date 객체를 반환한다. <code class="highlighter-rouge">value</code>가 문자열인 경우, 이 문자열이 나타내는 Date 객체를 반환한다.</li>
      <li><code class="highlighter-rouge">new Date(year, month, day, hour, minutes, seconds, milliseconds)</code> - 년, 월, 일, 시, 분, 초, 밀리초를 <strong>직접 입력</strong>해서 Date 객체를 생성할 수도 있다. ‘월’ 부분은 0부터 11까지의 값을 가진다. 월 이후의 인자는 생략가능하고, 인자를 생략하면 ‘일’은 1로, 나머지는 모두 0으로 지정된다.</li>
    </ol>
  </li>
</ol>

<p><br /></p>

<h5 id="322-문자열로-변환하기">3.2.2 문자열로 변환하기</h5>

<ol>
  <li>
    <p><code class="highlighter-rouge">Date</code> 객체가 나타내는 시각을 여러가지 방법으로 문자열로 변환할 수도 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">toString</span><span class="p">());</span> <span class="c1">// Sun Dec 10 2017 12:49:31 GMT+0900 (KST)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">toLocaleString</span><span class="p">());</span> <span class="c1">// 2017. 12. 10. 오후 12:49:31</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">toDateString</span><span class="p">());</span> <span class="c1">// Sun Dec 10 2017</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">toTimeString</span><span class="p">());</span> <span class="c1">// 12:49:31 GMT+0900 (KST)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">toISOString</span><span class="p">());</span> <span class="c1">// 2017-12-10T03:49:31.145Z</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">toUTCString</span><span class="p">());</span> <span class="c1">// Sun, 10 Dec 2017 03:49:31 GMT</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>날짜를 표기하는 방법에 국제 표준이 있다. 그 중 하나가 ISO 표준이다.</p>
  </li>
</ol>

<p><br /></p>

<h5 id="323-시간-간격-측정하기">3.2.3 시간 간격 측정하기</h5>

<ol>
  <li>
    <p><code class="highlighter-rouge">-</code> 연산자를 사용해서 두 <code class="highlighter-rouge">Date</code> 객체 사이의 시간 간격이 얼마나 되는지를 밀리초 단위로 측정할 수 있다. 그러나 <code class="highlighter-rouge">+</code> 연산을 사용하면 단순히 두 문자열을 이어붙인다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">start</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="s1">'시간이 가고 있습니다...'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">end</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span>
<span class="nx">alert</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">end</span> <span class="o">-</span> <span class="nx">start</span><span class="p">}</span><span class="s2"> 밀리초 만큼의 시간이 경과되었습니다.`</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>현재 시간으로부터 한 시간 뒤의 시간을 구하려면 아래와 같이 구한다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span>
<span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3600000</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h5 id="323-라이브러리-사용하기">3.2.3 라이브러리 사용하기</h5>

<ol>
  <li>
    <p>물론 Date 객체의 내장 메소드를 사용하여 원하는 시간을 표현할 수도 있지만, 매우 번거로운 일이다.</p>
  </li>
  <li>
    <p>moment.js는 ECMAScript 2015와 잘 맞지 않아서 data-fns로 세대교체가 일어나고 있는 중이다.</p>
  </li>
  <li>
    <p>JavaScript에 내장되어 있는 <code class="highlighter-rouge">Date</code> 객체는 컴퓨터에서 시간 데이터를 다루기 위한 기본적인 기능들을 제공하지만, 실제 서비스에서 사용하기에는 부족한 점이 많다. 이 때문에, 실무에서는 <a href="https://momentjs.com/">moment.js</a> 혹은 <a href="https://date-fns.org/">date-fns</a>와 같은 별도의 라이브러리를 사용하는 경우가 많다. <a href="https://runkit.com/seungha-kim/moment-example">이 링크</a>에서 가장 널리 사용되는 시간 관련 라이브러리인 moment.js를 시험해볼 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">moment</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"moment"</span><span class="p">)</span>
<span class="nx">moment</span><span class="p">.</span><span class="nx">locale</span><span class="p">(</span><span class="s1">'ko'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">now</span> <span class="o">=</span> <span class="nx">moment</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">format</span><span class="p">(</span><span class="s2">"dddd, MMMM Do YYYY, h:mm:ss a"</span><span class="p">));</span> <span class="c1">// 일요일, 12월 10일 2017, 1:02:42 오후</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">now</span><span class="p">.</span><span class="nx">subtract</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s1">'days'</span><span class="p">).</span><span class="nx">calendar</span><span class="p">());</span> <span class="c1">// 2017.12.03</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">moment</span><span class="p">(</span><span class="s2">"20120101"</span><span class="p">,</span> <span class="s2">"YYYYMMDD"</span><span class="p">).</span><span class="nx">fromNow</span><span class="p">());</span> <span class="c1">// 6년 전</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><br /></p>

<h4 id="33-symbol">3.3 Symbol</h4>

<ol>
  <li>
    <p>심볼은 ES2015에서 도입된 새로운 원시 타입이다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Symbol</code> 내장 함수를 통해 새 심볼을 생성할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sym</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">sym</span><span class="p">);</span> <span class="c1">// symbol</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sym</span><span class="p">);</span> <span class="c1">// Symbol()</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">obj</code>라는 이름의 객체가 있고 해당 객체에 외부로 공개하고 싶지 않은 <code class="highlighter-rouge">_won</code> 속성이 있다고 하자. <code class="highlighter-rouge">_</code>를 사용하여 그 뜻을 밝혔다 하더라도 <code class="highlighter-rouge">obj._won</code>으로 접근하여 해당 속성을 마음대로 읽고 수정할 수 있었는데, 이 문제를 해결하기 위해 Symbol 원시 타입이 이 고안되었다.</p>
  </li>
  <li>
    <p>ES2015 이전에는 객체의 속성 키로 문자열만 사용할 수 있었다. 즉, 숫자나 객체 등은 객체의 속성 키로 사용할 수 없다. ES2015에서 추가된 Symbol은 객체의 속성 키로 사용될 수 있고, 해당 키를 호출할 때는 대괄효 표기법으로만 호출할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 심볼은 객체의 속성 키로 사용될 수 있다.</span>
<span class="kd">const</span> <span class="nx">mySymbol</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="s1">'my symbol'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">mySymbol</span><span class="p">]:</span> <span class="s1">'hello'</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">// { [Symbol(my symbol)]: 'hello' }</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">Symbol</code> 함수에 문자열을 넘겨서, 해당 심볼에 대한 설명을 포함한 심볼을 생성할 수 있다. 이 때 넘겨지는 문자열은 그저 심볼의 설명일 뿐이므로, 심볼의 비교 연산에 영향을 주지 않는다. 즉, 어떤 문자열이 인자열에 들어오는 지와 상관없이 <strong>새로 생성된 심볼은 다른 모든 심볼과 다른 것으로 취급됩니다.</strong></p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Symbol</span><span class="p">(</span><span class="s1">'my symbol'</span><span class="p">));</span> <span class="c1">// Symbol(my symbol)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Symbol</span><span class="p">(</span><span class="s1">'my symbol'</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Symbol</span><span class="p">(</span><span class="s1">'my symbol'</span><span class="p">));</span> <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Symbol</span><span class="p">()</span> <span class="o">===</span> <span class="nb">Symbol</span><span class="p">());</span> <span class="c1">// false</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Symbol이 처음 고안되었던 것은 정보를 숨기기 위함이었는데, 시간이 지나 용도가 많이 변경되었다. 보통 객체의 기능을 확장하고자 할 때 사용된다. <strong>내장 심볼(well-known symbol)</strong>을 객체의 속성 키로 사용하면, 특정 상황에서의 객체의 동작 방식을 마음대로 바꿀 수 있다.</p>

    <ol>
      <li><code class="highlighter-rouge">Symbol.hasInstance</code> - 객체가 <code class="highlighter-rouge">instanceof</code> 연산자의 피연산자로 왔을 때의 동작을 바꾼다.</li>
      <li><code class="highlighter-rouge">Symbol.isConcatSpreadable</code> - 객체가 <code class="highlighter-rouge">Array.prototype.concat</code> 메소드의 인자로 넘겨질 때의 동작을 바꾼다.</li>
      <li><code class="highlighter-rouge">Symbol.iterator</code> - 객체가 <code class="highlighter-rouge">for...of</code> 구문을 통해 사용될 때의 동작 방식을 바꾼다.</li>
      <li><code class="highlighter-rouge">Symbol.match</code> - 객체가 <code class="highlighter-rouge">String.prototype.match</code> 메소드의 인자로 넘겨질 때의 동작을 바꾼다.</li>
      <li><code class="highlighter-rouge">Symbol.replace</code> - 객체가 <code class="highlighter-rouge">String.prototype.replace</code> 메소드의 인자로 넘겨질 때의 동작을 바꾼다.</li>
      <li><code class="highlighter-rouge">Symbol.search</code> - 객체가 <code class="highlighter-rouge">String.prototype.search</code> 메소드의 인자로 넘겨질 때의 동작을 바꾼다.</li>
      <li><code class="highlighter-rouge">Symbol.species</code> - <code class="highlighter-rouge">Array.prototype</code>을 상속받은 객체에 대해 <code class="highlighter-rouge">Array.prototype.map</code> 등의 메소드를 호출할 때, 반환되는 객체의 생성자를 지정한다.</li>
      <li><code class="highlighter-rouge">Symbol.split</code> - 객체가 <code class="highlighter-rouge">String.prototype.split</code> 메소드의 인자로 넘겨질 때의 동작을 바꾼다.</li>
      <li><code class="highlighter-rouge">Symbol.toPrimitive</code> - 객체가 원시 타입의 값으로 변환되어야 할 때, 정확이 어떤 값으로 변환되어야 하는 지를 지정한다.</li>
      <li><code class="highlighter-rouge">Symbol.toStringTag</code> - <code class="highlighter-rouge">Object.prototype.toString()</code> 메소드를 객체에 대해 직접 호출할 때의 동작을 바꾼다.</li>
      <li><code class="highlighter-rouge">Symbol.unscopable</code> - <code class="highlighter-rouge">with</code> 블록 안에서 어떤 속성을 참조할 수 있는 지를 지정한다.</li>
      <li>나머지 심볼에 대해 자세히 알아보려면 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">MDN 문서</a>를 참고한다.</li>
    </ol>
  </li>
</ol>

<p><br /></p>

<h4 id="34-map">3.4 Map</h4>

<ol>
  <li>
    <p>객체와 비슷하게 사용될 수 있는 자료 구조이다. 그러나 객체와 사용법이 다르고, 동작 방식도 다르다.</p>
  </li>
  <li>
    <p>ES2015에서 도입된 <code class="highlighter-rouge">Map</code> 생성자는 객체와 유사하게 <strong>키-값 쌍(key-value pair)</strong>을 저장할 수 있는 새로운 자료구조를 제공한다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>

<span class="nx">m</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">,</span> <span class="s1">'world'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">));</span> <span class="c1">// 'world'</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">));</span> <span class="c1">// true</span>

<span class="nx">m</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">));</span> <span class="c1">// undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">));</span> <span class="c1">// false</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">Map</code>으로 생성된 객체는, 일반적인 객체와 비교했을 때 아래와 같은 차이점을 갖는다.</p>

    <ol>
      <li>객체는 속성 접근자(property accessor) 문법을 통해서, <code class="highlighter-rouge">Map</code>은 <strong>메소드</strong>를 통해서 내부의 데이터를 조작한다.</li>
      <li>문자열과 심볼만이 객체의 속성 키가 될 수 있는 반면, <strong>어떤 값이라도 Map 객체의 키로 사용될 수 있다.</strong> 객체 또한 객체의 키로 사용할 수 있다.</li>
      <li>객체의 속성을 확인할 때는 프로토타입 체인을 확인하는 과정에 필요하지만, <code class="highlighter-rouge">Map</code> 객체 안에 들어있는 데이터는 <strong>프로토타입의 영향을 받지 않는다.</strong></li>
      <li><code class="highlighter-rouge">Map</code> 객체의 <code class="highlighter-rouge">size</code> 속성을 통해 내부에 들어있는 <strong>데이터의 갯수</strong>를 쉽게 알 수 있다.</li>
    </ol>
  </li>
  <li>
    <p><code class="highlighter-rouge">Map</code> 객체는 <strong>데이터의 추가 / 삭제가 빈번하게 일어나는 경우</strong> 일반적인 객체보다 훨씬 빠르게 동작한다는 장점이 있는 반면, JSON 등으로 <strong>직렬화 하기 어렵다</strong>는 특징이 있다. 키-값 쌍 형태의 데이터를 다루면서 속도가 중요한 경우에는 <code class="highlighter-rouge">Map</code>의 사용을 고려한다.</p>
  </li>
  <li>
    <p>객체에 속성 키의 값으로 어떤 것을 넘기던 간에 문자열로 바뀌어 처리된다.</p>
  </li>
</ol>

<p><br /></p>

<h4 id="35-set">3.5 Set</h4>

<ol>
  <li>
    <p>ES2015에서 도입된 <code class="highlighter-rouge">Set</code> 생성자는 <strong>집합</strong> 형태의 자료구조를 제공한다. <code class="highlighter-rouge">Set</code> 객체 내부에 이미 존재하는 데이터를 추가하려고 하면, 이는 무시됩니다. 즉, <code class="highlighter-rouge">Set</code> 객체는 내부에 <strong>중복된 데이터가 저장되는 것을 허용하지 않는다</strong>.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>

<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// Set { 1, 2 }</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>배열과 유사한 형태의 자료구조</strong>가 필요하지만 <strong>순서가 중요하지 않은 경우,</strong> 그리고 <strong>중복된 데이터의 저장을 허용하지 않아야</strong> 할 경우, <code class="highlighter-rouge">Set</code>의 사용을 고려한다.</p>
  </li>
  <li>
    <p>객체를 추가할 때에는 참조에 대한 값이 복사되므로 모양이 같더라도 참조가 다르면 추가될 수 있다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Set.prototype.delete(value)</code>로 원소를 삭제할 수 있다.</p>
  </li>
  <li>
    <p>집합에는 index의 개념이 없다. Set이 갖고 있는 원소로 어떤 작업을 수행하려면 <code class="highlighter-rouge">for ~ of</code>로 수행한다.</p>
  </li>
  <li>
    <p>자주 사용되진 않으나 중복을 제거할 때 사용할 수 있다.</p>

    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// Set { 1 }</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// Set { 1 }</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// Set { 1, 2 }</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// Set { 1, 2, [ 1 ] }</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// Set { 1, 2, [ 1 ], [ 1 ] }</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span>

<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// Set { 1, 2, [ 1 ], [ 1 ], { b: 2 } }</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// Set { 1, 2, [ 1 ], [ 1 ], { b: 2 }, { b: 2 } }</span>

<span class="kd">const</span> <span class="nx">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">(</span><span class="s1">'aaaa'</span><span class="p">)</span> <span class="c1">// Set { 'a' }</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">MDN - Set</a></p>
  </li>
</ol>

<p><br /></p>

<h4 id="36-기타">3.6 기타</h4>

<ol>
  <li>이 밖에, ES2015 또는 그 이후에 추가된 여러가지 내장 객체 및 생성자들이 있다.
    <ol>
      <li><code class="highlighter-rouge">Proxy</code> - 다른 객체처럼 행세하면서, 특정한 행동에 대해서는 다른 동작 방식을 보이는 새로운 객체를 만들고 싶을 때 사용한다.</li>
      <li><code class="highlighter-rouge">Reflect</code> - <code class="highlighter-rouge">Reflect</code> 객체의 메소드를 통해, JavaScript의 몇 가지 내장 기능을 메소드로서 사용할 수 있다.</li>
      <li><code class="highlighter-rouge">Intl</code> - <code class="highlighter-rouge">Intl</code> 객체를 이용하면, 사용 중인 언어에 따라 문자열 비교, 숫자 표현 형식, 시간 표현 형식을 바꿀 수 있다.</li>
      <li><code class="highlighter-rouge">WeakMap</code> - <code class="highlighter-rouge">Map</code> 생성자와 사용법이 같지만, 키로 사용된 값에 대한 메모리 누수를 방지할 수 있다.</li>
      <li><code class="highlighter-rouge">WeakSet</code> - <code class="highlighter-rouge">Set</code> 생성자와 사용법이 같지만, 집합에 추가된 값에 대한 메모리 누수를 방지할 수 있다.</li>
      <li><code class="highlighter-rouge">TypedArray</code> - 이진 데이터(binary data)를 다룰 수 있는 방법을 제공한다. File API, Canvas, Fetch API 등에서 사용된다.</li>
    </ol>
  </li>
  <li>위 내장 객체들을 직접 사용할 일은 별로 없다. 후에 라이브러리를 개발할 정도의 개발자가 되었을 때 사용을 고려해볼 수 있다.</li>
</ol>

<p><br /></p>

<blockquote>
  <h5 id="garbage-collection">garbage collection</h5>

  <ol>
    <li>함수 내에서 선언된 변수는 함수가 종료되는 동시에 그 주기는 끝나게 된다. 이때 버려지는 소속 변수들을 처리하는 것을 garbage collection이라고 한다.</li>
  </ol>
</blockquote>

<p><br /></p>

<h3 id="4-브라우저-측-javascript">4. 브라우저 측 JavaScript</h3>

<ol>
  <li>코드의 중복은 유지보수를 어렵게 만든다. 같은 코드가 재사용되는 부분은 함수 단위로 만들어 관리한다.</li>
</ol>

        <div class="page-footer">
          <div class="page-tag">
            <span>Tags:</span>
            
            <a href="/tags#패스트캠퍼스" class="tag">| 패스트캠퍼스</a>
            
            <a href="/tags#til" class="tag">| til</a>
            
            <a href="/tags#js" class="tag">| js</a>
            
            <a href="/tags#javascript" class="tag">| javascript</a>
            
          </div><!-- End Tags -->
          <div class="page-share">
            <span>Share:</span>
            <a href="https://twitter.com/intent/tweet?text=17년 12월 21일 수업 내용 정리&url=http://localhost:4000/learn/til/js-11/" title="Share on Twitter" rel="nofollow" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
            <a href="https://facebook.com/sharer.php?u=http://localhost:4000/learn/til/js-11/" title="Share on Facebook" rel="nofollow" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
            <a href="https://plus.google.com/share?url=http://localhost:4000/learn/til/js-11/" title="Share on Google+" rel="nofollow" target="_blank"><i class="fa fa-google" aria-hidden="true"></i></a>
          </div><!-- End Share -->
        </div>
        <section class="author-box">
  <img src="/assets/img/chayeoi-profile.jpg" alt="Chanyeon Kim" class="author-img">
  <div class="author-desc">
    <h2>Chanyeon Kim</h2>
    <p>자바스크립트를 무척 좋아하는 주니어 프론트엔드 개발자입니다. 현재 React.js, Vue.js, Node.js를 공부 중에 있습니다.</p>
    <ul>
      
        <li class="github"><a href="http://github.com/chayeoi" target="_blank"><i class="fa fa-github"></i></a></li>
      
      
        <li class="facebook"><a href="https://facebook.com/chayeoi" target="_blank"><i class="fa fa-facebook"></i></a></li>
      
      
        <li class="instagram"><a href="https://instagram.com/chayeoi" target="_blank"><i class="fa fa-instagram"></i></a></li>
      
      <!-- 
        <li class="email"><a href="mailto:y2oniary@gmail.com"><i class="fa fa-envelope-o"></i></a></li>
       -->
      <!-- 
        <li class="phone"><a href="tel:010-2650-5090"><i class="fa fa-phone"></i></a></li>
       -->
      
        <li class="website"><a href="http://chayeoi.creatorlink.net" target="_blank"><i class="fa fa-globe"></i></a></li>
      
      <!-- 
        <li class="twitter"><a href="https://twitter.com/artemsheludko_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
       -->
    </ul>
  </div>
</section>
        <div class="recent-box">
  <h2 class="recent-title">Recent post</h2>
  <div class="recent-list">
    
      
        <a href="/learn/js/this/" class="recent-item" style="background: url(/assets/img/post-js.jpg) center no-repeat; background-size: cover;"><span>this 바인딩 규칙</span></a>
      
    
      
        <a href="/learn/etc/jekyll/" class="recent-item" style="background: url(/assets/img/post-etc.jpg) center no-repeat; background-size: cover;"><span>Jekyll 블로그 만들기</span></a>
      
    
      
        <a href="/learn/html5/outline/" class="recent-item" style="background: url(/assets/img/post-html.jpg) center no-repeat; background-size: cover;"><span>HTML5 Outline 알고리즘</span></a>
      
    
      
        <a href="/learn/css3/css/" class="recent-item" style="background: url(/assets/img/post-css.jpg) center no-repeat; background-size: cover;"><span>CSS 손보잣</span></a>
      
    
  </div>
</div> <!-- End Recent-Box -->

        <section class="comment-area">
  <div class="comment-wrapper">
    
    <div id="disqus_thread" class="article-comments"></div>
    <script>
      (function() {
          var d = document, s = d.createElement('script');
          s.src = '//y2oniary.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
  </div>
</section> <!-- End Comment Area -->

      </div>
    </div> <!-- End Wrapper -->
  </article>
  <div class="search-box">
  <div class="wrapper">
    <div class="search-grid">
      <form class="search-form">
        <div id="search-container">
          <input type="text" id="search-input" class="search" placeholder="Search">
        </div>
      </form>
      <ul id="results-container" class="results-search"></ul>
      <div class="icon-close-container">
        <span class="search-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
      </div>
    </div>
  </div>
</div>

  <footer class="main-footer">
  <div class="copyright">
    <p>2018 &copy; Chanyeon Kim</p>
  </div>
</footer> <!-- End Footer -->

</div>

  <!-- JS -->
<script src="/assets/js/jquery-3.2.1.min.js"></script>
<script src="/assets/js/jekyll-search.js"></script>
<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
    noResultsText: 'No results found',
    fuzzy: false,
    exclude: ['Welcome']
  });
</script>
<script src="/assets/js/main.js"></script>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

</body>
</html>
